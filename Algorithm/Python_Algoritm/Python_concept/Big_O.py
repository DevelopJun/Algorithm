'''
빅오 Big_O 는 알고리즘을 다루는 거의 모든 착에서 상세히 다루는 중요한 주제중 하나이다.
컴퓨터 과학에서 빅오는 입력값이 커질 때 알고리즘의 실행 시간(시간 복잡도)과 함께 공간 요구사항이 어떻게 증가하는지를 분류하는데 사용되며,
알고리즘의 효율성을 분석하는 데에도 매우 유용항하다. 

먼저 빅오는 점근적 실행 시간을 표기할 때 가장 널리는 쓰이는 수학적 표기 방식이다. 
점근적 실행시간이라 입력값 n 값이 커질때 , 즉 입력값이 무한대를 향할때 lim 함수의 실행 시간의 추이를 의미한다. 

점근적 실행 시간을 시간 복잡도라고 말하는 것이다. 시간 복잡도 time complexity의 사전적 정의는 알고리즘 걸리는 시간을 설명하는
계산 복잡도를 의미하며, 이를 표현하는 방식이 빅오 표기법이다. 

O(1): 입력값이 아무리 커도 실행 시간은 일정하다. 최고의 알고리즘이라고 하기 도하고, 상수 시간을 찾는 알고리즘은 성배와 같아서
찾을 수 만 있다면 놀라울 정도로 가치가 있지만, 그 성배를 찾기 위해서 한 평생을 보내야할 지도 모른다. 따라서 누군가 O(1)을 이야기 한다면
의심해봐야 한다. O(1)에 실행되는 알고리즘으로 해시 테이블의 조회 및 삽입 

O(log n): 여기서부터 실행 시간은 입력값에 영향을 받는다. 그러나 로그는 매우 큰 입력값에도 크게 영향을 받지 않음으로, 
왠만한 n의 크기에 대해서도 매우 견고하다. 예를 들어 이진 탐색이 존재한다. 

O(n): 입력값 만큼 실행 시간에 영향을 받으며, 알고리즘 수행 시간은 입력값에 비례한다. 이러한 알고리즘을 선형 시간 알고리즘이라고 한다.
정렬되지 않는 리스트에서 최댓값 또는 최솟값 찾는 경우가 이에 해당되며, 이 값을 찾기 위해서 적어도 한번 이상 입력값 봐야 한다.

O(n lon n): 병합 정렬 을 비롯한 대부분의 효율 좋은 정렬 알고리즘이 이에 해당한다. 적어도 모든 수에 대해 한 번 이상은 비교해야 하는 비교 기반 정렬
알고리즘은 아무리 좋은 알고리즘도 O(n log n)보다 빠를 수 없다. 

O(n2): 버블 정렬 같은 비 효율적인 정렬 알고리즘 방식이 이에 해당한다. 

O(2n): 피보나치 수로 재귀를 계산할때, 간혹 n2과 혼동되는데 완전 다르고 이게 훨씬 크다. 

----> 실행시간이 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행 시간이 느리다. 
'''
